library(DiceKriging)
library(lhs)



# GP - Lower Confidence Bound
gp.lcb <- function(x,gp,beta=1) {
  stopifnot(is.vector(x))
  x = t(x)
  pred = predict(gp,data.frame(x),"UK",checkNames=F)
  lcb = pred$mean-sqrt(beta)*pred$sd
}

# GP's predictive mean
gp.mu <- function(x,gp) {
  stopifnot(is.vector(x))
  x = t(x)
  pred = predict(gp,data.frame(x),"UK",checkNames=F)
  gp.mu = pred$mean
} 

# GP's predictive uncertainty
gp.sd <- function(x,gp) {
  stopifnot(is.vector(x))
  x = t(x)
  pred = predict(gp,data.frame(x),"UK",checkNames=F)
  gp.sd = pred$sd
}

# Inverse Weighted Distance (model-free uncertainty)
idw <- function(x,XX,dgt) {
  D = as.matrix(dist(rbind(x,XX)))
  D = D[1,-1]
  w = exp(-D^2) / (D)^2
  if(length(which(D<10^-dgt))>0) { 
    z = 0
  } else {
    z = (2/pi) * atan( 1/sum(w) )
  }
  idw = z
}

# function assessing if points X belongs to the hypercube
# with side L and centered in xc
inHypercube <- function(X,xc,L) {
  stopifnot( is.matrix(X) & is.vector(xc) )
  counter = 0
  for( i in 1:nrow(X) ) {
    ixs = which( abs(xc-X[i,])<L/2 )
    if( length(ixs)>0 )
      counter= counter+1
  }
  inHypercube = counter
}



# Probability of Improvement as defined in "PI is back!" paper
PI <- function(x,gp) {
  stopifnot(is.vector(x))
  x = t(x)
  pred = predict(gp,data.frame(x),"UK",checkNames=F)
  I = min(gp@y) - pred$mean

  # cdf  
  if( I < .Machine$double.eps ) {
    PI = 0 # to deal with 0/0 situation and avoid NaN
  } else {
    PI = pnorm( q=I/pred$sd, mean=0, sd=1 )  
  }

  if( is.na(PI) || is.infinite(PI) ) {
    cat("\n*NOOOOOO! (PI)*\n")
    print(PI)
  } else {
    return(PI)
  }
    
}

# Expected Improvement as defined in "PI is back!" paper
EI <- function(x,gp,dgt) {
  stopifnot(is.vector(x))
  x = t(x)
  pred = predict(gp,data.frame(x),"UK",checkNames=F)
  if(pred$sd<10^-dgt) {
    res = 0
  } else {
    I = min(gp@y) - pred$mean
    
    res = I * pnorm( q=I/pred$sd, mean=0, sd=1 )
            + pred$sd * dnorm( x=I/pred$sd, mean=0, sd=1 )
  }
  
  # cdf
  EI = res
  
  if( is.na(EI) || is.infinite(EI) ) {
    cat("\n*NOOOOOO! (EI)*\n")
    print(EI)
  } else {
    return(EI)
  }
}





# GP-LCB with Srinivas's scheduling for beta (Theorem 1)
next.Srinivas_1 <- function(gp,dgt,delta,lbfgsb=F) {
  beta = 2 * log10( (10^(dgt*gp@d)) * ((pi*length(gp@y))^2) / (6*delta)  )
  beta = beta/5 # <-- empirical workaround adopted in Srinivas
  beta =  round(beta,dgt)
  
  if( lbfgsb ) {
    x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
    y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
    x0s = x0s[order(y0s,decreasing=F)[1:5],]
    for( i in 1:nrow(x0s) ) {
      x0 = x0s[i,]
      res = optim(par=x0,fn=gp.lcb,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                  control=list(trace=0,factr=10^-dgt),
                  gp=gp,beta=beta)
      if( i==1 || res$value<res.best$value )
        res.best = res
    }
  } else {
    xc = xc.prev = rep(0.5,gp@d)
    notImproved = 0
    len = 1
    while( notImproved<5 && len>=0.01 ) {
      x0s = round( maximinLHS(100*gp@d,gp@d) * len + xc-len/2, dgt )
      x0s = rbind(xc,x0s)
      x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
      y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
      xc = x0s[which.min(y0s),]
      len = 3 * len/4
      if( all(xc==xc.prev) ) {
        notImproved = notImproved+1
      } else {
        xc.prev = xc
        notImproved = 0
      }
    }
    res.best = list(par=xc)
  }
  next.Srinivas_1 = list(par=res.best$par,af.info="LCB",af.note=paste0("beta=",beta))
}

# GP-LCB with Srinivas's scheduling for beta (Theorem 2+'empirical workaround' on beta)
next.Srinivas_2 <- function(gp,dgt,delta,lbfgsb=F) {
  
  # ----------------------------------
  # fixed as in the reference paper
  r=1
  a=b=1
  # ----------------------------------
  
  beta = 2*log10( ((pi*length(gp@y))^2)/(3*delta) ) + (2*gp@d) * log10(sqrt(log10(4*gp@d*a/delta))*gp@d*b*r*length(gp@y)^2)
  beta = beta/5 # <-- empirical workaround adopted in Srinivas
  beta =  round(beta,dgt)
  
  if( lbfgsb ) {
    x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
    y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
    x0s = x0s[order(y0s,decreasing=F)[1:5],]
    for( i in 1:nrow(x0s) ) {
      x0 = x0s[i,]
      res = optim(par=x0,fn=gp.lcb,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                  control=list(trace=0,factr=10^-dgt),
                  gp=gp,beta=beta)
      if( i==1 || res$value<res.best$value )
        res.best = res
    }
  } else {
    xc = xc.prev = rep(0.5,gp@d)
    notImproved = 0
    len = 1
    while( notImproved<5 && len>=0.01 ) {
      x0s = round( maximinLHS(100*gp@d,gp@d) * len + xc-len/2,dgt )
      x0s = rbind(xc,x0s)
      x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
      y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
      xc = x0s[which.min(y0s),]
      len = 3 * len/4
      if( all(xc==xc.prev) ) {
        notImproved = notImproved+1
      } else {
        xc.prev = xc
        notImproved = 0
      }
    }
    res.best = list(par=xc)
  }
  next.Srinivas_2 = list(par=res.best$par,af.info="LCB",af.note=paste0("beta=",beta))
}

# Epsilon-greedy LCB / Random Search
next.epsRS <- function(gp,epsilon,lbfgsb=F) {
  if( runif(1,0,1)<epsilon ) {
    info = "random"
    par = round(runif(gp@d),dgt)
  } else {
    if( lbfgsb ) {
      x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
      # GP's mu!
      y0s = round(apply(x0s,1,gp.mu,gp=gp),dgt)
      x0s = x0s[order(y0s,decreasing=F)[1:5],]
      for( i in 1:nrow(x0s) ) {
        x0 = x0s[i,]
        # GP's mu!
        res = optim(par=x0,fn=gp.mu,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt),
                    gp=gp)
        if( i==1 || res$value<res.best$value )
          res.best = res
      }
    } else {
      xc = xc.prev = rep(0.5,gp@d)
      notImproved = 0
      len = 1
      while( notImproved<5 && len>=0.01 ) {
        x0s = round( maximinLHS(100*gp@d,gp@d) * len + xc-len/2, dgt )
        x0s = rbind(xc,x0s)
        x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
        # GP's mu!
        y0s = round(apply(x0s,1,gp.mu,gp=gp),dgt)
        xc = x0s[which.min(y0s),]
        len = 3 * len/4
        if( all(xc==xc.prev) ) {
          notImproved = notImproved+1
        } else {
          xc.prev = xc
          notImproved = 0
        }
      }
      res.best = list(par=xc)
    }
    
    info = "greedy"
    par = res.best$par
  }
  
  next.epsRS = list(par=par,af.info=info,af.note=paste0("epsilon=",epsilon))
}

# Epsilon-greedy LCB / Random on Pareto Front
next.epsPareto <- function(gp,epsilon,lbfgsb=F) {
  
  if( runif(1,0,1)<epsilon ) {
    # There is no need to sample from a Gamma distribution, as in "Randomised GP-UCB for BO",
    # According to Zilinskas & Calvin, GP-UCB is on the Pareto whichever is beta! Therefore
    # we sample uniformly at random beta in [0;36], that is sqrt(beta) in [0;6], according to
    # the different Gaussian distribution's confidence intervals
    
    beta = round(runif(1,0,36))
    
    if( lbfgsb ) {
      x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
      y0s = round(apply(x0s,1,gp.lcb,gp=gp),dgt) # <-- Pareto choice!
      x0s = x0s[order(y0s,decreasing=F)[1:5],]
      for( i in 1:nrow(x0s) ) {
        x0 = x0s[i,]
        res = optim(par=x0,fn=gp.lcb,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt),
                    gp=gp,beta=beta) # <-- Pareto choice!
        if( i==1 || res$value<res.best$value )
          res.best = res
      }
    } else {
      xc = xc.prev = rep(0.5,gp@d)
      notImproved = 0
      len = 1
      while( notImproved<5 && len>=0.01 ) {
        x0s = round( maximinLHS(100*gp@d,gp@d)* len + xc-len/2, dgt )
        x0s = rbind(xc,x0s)
        x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
        y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt) # <-- Pareto choice!
        xc = x0s[which.min(y0s),]
        len = 3 * len/4
        if( all(xc==xc.prev) ) {
          notImproved = notImproved+1
        } else {
          xc.prev = xc
          notImproved = 0
        }
      }
      res.best = list(par=xc)
    }
    
    info = "Pareto"
    par = res.best$par
    
  } else {
    
    if( lbfgsb ) {
      x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
      # GP's mu!
      y0s = round( apply(x0s,1,gp.mu,gp=gp), dgt)
      x0s = x0s[order(y0s,decreasing=F)[1:5],]
      for( i in 1:nrow(x0s) ) {
        x0 = x0s[i,]
        # GP's mu
        res = optim(par=x0,fn=gp.mu,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt),
                    gp=gp)
        if( i==1 || res$value<res.best$value )
          res.best = res
      }
    } else {
      xc = xc.prev = rep(0.5,gp@d)
      notImproved = 0
      len = 1
      while( notImproved<5 && len>=0.01 ) {
        x0s = round( maximinLHS(100*gp@d,gp@d) * len + xc-len/2, dgt )
        x0s = rbind(xc,x0s)
        x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
        # GP's mu!
        y0s = round(apply(x0s,1,gp.mu,gp=gp),dgt)
        xc = x0s[which.min(y0s),]
        len = 3 * len/4
        if( all(xc==xc.prev) ) {
          notImproved = notImproved+1
        } else {
          xc.prev = xc
          notImproved = 0
        }
      }
      res.best = list(par=xc)
    }
    
    info = "greedy"
    par = res.best$par
  }

  next.epsPareto = list(par=par,af.info=info,af.note=paste0("epsilon=",epsilon))
}



# Master Confidence Bound
next.masterAF <- function(gp,L,nu,beta,dgt,lbfgsb=F) {
  
  best.x = gp@X[which.min(gp@y),]
  
  # next solution as usual....
  if( lbfgsb ) {
    x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
    y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
    x0s = x0s[order(y0s,decreasing=F)[1:5],]
    for( i in 1:nrow(x0s) ) {
      x0 = x0s[i,]
      res = optim(par=x0,fn=gp.lcb,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                  control=list(trace=0,factr=10^-dgt),
                  gp=gp,beta=beta)
      if( i==1 || res$value<res.best$value )
        res.best = res
    }
  } else {
    xc = xc.prev = rep(0.5,gp@d)
    notImproved = 0
    len = 1
    while( notImproved<5 && len>=0.01 ) {
      x0s = round( maximinLHS(100*gp@d,gp@d) * len + xc-len/2, dgt )
      x0s = rbind(xc,x0s)
      x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
      y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
      xc = x0s[which.min(y0s),]
      len = 3 * len/4
      if( all(xc==xc.prev) ) {
        notImproved = notImproved+1
      } else {
        xc.prev = xc
        notImproved = 0
      }
    }
    res.best = list(par=xc)
  }
  info = "LCB"
  
  # Check for usefulness!
  if( inHypercube(X=rbind(gp@X,res.best$par),xc=best.x,L=L)>=nu ) {
    
    info = "UR"
    
    # discard! and select to reduce uncertainty! therefore maximize idw!
    
    if( lbfgsb ) {
      x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
      y0s = round(apply(x0s,1,idw,XX=as.matrix(gp@X),dgt=dgt),dgt)
      x0s = x0s[order(y0s,decreasing=T)[1:5],] # <-- because idw must be maximized!
      for( i in 1:nrow(x0s) ) {
        x0 = x0s[i,]
        # maximize idw!!!!
        res = optim(par=x0,fn=idw,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt,fnscale=-1), # <-- fnscale=-1 to maximize
                    XX=as.matrix(gp@X),dgt=dgt)
        if( i==1 || res$value>res.best$value ) # <- because iwd is maximized!
          res.best = res
      }
    } else {
      xc = xc.prev = rep(0.5,gp@d)
      notImproved = 0
      len = 1
      while( notImproved<5 && len>=0.01 ) {
        x0s = round(maximinLHS(100*gp@d,gp@d),dgt) * len + xc-len/2
        x0s = rbind(xc,x0s)
        x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
        y0s = round(apply(x0s,1,idw,XX=as.matrix(gp@X),dgt=dgt),dgt)
        
        xc = x0s[which.max(y0s),] # <-- because iwd is maximized!
        len = 3 * len/4
        if( all(xc==xc.prev) ) {
          notImproved = notImproved+1
        } else {
          xc.prev = xc
          notImproved = 0
        }
      }
      res.best = list(par=xc)
    }
  
  }
  
  next.masterCB = list(par=res.best$par,af.info=info,af.note=paste0("L=",L,";nu=",nu,";beta=",beta))
}


# GP-CB with constant beta
next.CB <- function(gp,beta,dgt,lbfgsb=F) {
  if( lbfgsb ) {
    x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
    y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
    x0s = x0s[order(y0s,decreasing=F)[1:5],]
    for( i in 1:nrow(x0s) ) {
      x0 = x0s[i,]
      res = optim(par=x0,fn=gp.lcb,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                  control=list(trace=0,factr=10^-dgt),
                  gp=gp,beta=beta)
      if( i==1 || res$value<res.best$value )
        res.best = res
    }
  } else {
    xc = xc.prev = rep(0.5,gp@d)
    notImproved = 0
    len = 1
    while( notImproved<5 && len>=0.01 ) {
      x0s = round(maximinLHS(100*gp@d,gp@d) * len + xc-len/2, dgt)
      x0s = rbind(xc,x0s)
      x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
      y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
      xc = x0s[which.min(y0s),]
      len = 3 * len/4
      if( all(xc==xc.prev) ) {
        notImproved = notImproved+1
      } else {
        xc.prev = xc
        notImproved = 0
      }
    }
    res.best = list(par=xc)
  }
  
  par = res.best$par

  next.CB = list(par=res.best$par,af.info="LCB",af.note=paste0("beta=",beta))
}

# Randomised GP-CB
next.randCB <- function(gp,theta,dgt,lbfgsb=F) {
  
  k_t = log10( (nrow(gp@X)^2+1) / sqrt(2*pi) ) / log10(1+theta/2)
  
  beta_t = rgamma(1,k_t,scale=theta)
  
  next.randCB = next.CB(gp=gp,beta=beta_t,dgt=dgt,lbfgsb=lbfgsb)
  
}



# "PI is back!" - Alternating between EI and PI
next.PIisBack.alternating <- function(gp,dgt,lbfgsb=F) {
  if( lbfgsb ) {
    x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
    if( nrow(gp@X)%%2==0 ) {
      y0s = round(apply(x0s,1,EI,gp=gp,dgt=dgt),dgt)
    } else {
      y0s = round(apply(x0s,1,PI,gp=gp),dgt)
    }
    x0s = x0s[order(y0s,decreasing=T)[1:5],] # <-- EI and PI are maximized!
    for( i in 1:nrow(x0s) ) {
      x0 = x0s[i,]
      if( nrow(gp@X)%%2==0 ) {
        res = optim(par=x0,fn=EI,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt,fnscale=-1), # <-- because EI is maximized!
                    gp=gp,dgt=dgt)
        info = "EI"
      } else {
        res = optim(par=x0,fn=PI,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt,fnscale=-1), # <-- because PI is maximized
                    gp=gp)
        info = "PI"
      }
      if( i==1 || res$value>res.best$value ) # <-- because EI and PI are maximized!
        res.best = res
    }
  } else {
    xc = xc.prev = rep(0.5,gp@d)
    notImproved = 0
    len = 1
    while( notImproved<5 && len>=0.01 ) {
      x0s = round(maximinLHS(100*gp@d,gp@d) * len + xc-len/2, dgt)
      x0s = rbind(xc,x0s)
      x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
      
      if( nrow(gp@X)%%2==0 ) {
        # EI
        y0s = round(apply(x0s,1,EI,gp=gp,dgt=dgt),dgt)
        info = "EI"
      } else { 
        # PI
        y0s = round(apply(x0s,1,PI,gp=gp),dgt)
        info = "PI"
      }
      
      xc = x0s[which.max(y0s),] # <-- because EI and PI are maximized!
      len = 3 * len/4
      if( all(xc==xc.prev) ) {
        notImproved = notImproved+1
      } else {
        xc.prev = xc
        notImproved = 0
      }
    }
    res.best = list(par=xc)
  }
  
  par = res.best$par  

  next.PIisBack.alternating = list(par=res.best$par,af.info=info,af.note=NA)
}

# "PI is back!" - Switching from EI to PI
next.PIisBack.switching <- function(gp,N,rate,dgt,lbfgsb=F) {
  if( lbfgsb ) {
    x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
    if( nrow(gp@X)<=floor(N*rate) ) {
      y0s = round(apply(x0s,1,EI,gp=gp,dgt=dgt),dgt)
    } else {
      y0s = round(apply(x0s,1,PI,gp=gp),dgt)
    }
    x0s = x0s[order(y0s,decreasing=T)[1:5],] # <-- because EI and PI are maximized!
    for( i in 1:nrow(x0s) ) {
      x0 = x0s[i,]
      if( nrow(gp@X)<=floor(N*rate) ) {
        res = optim(par=x0,fn=EI,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt,fnscale=-1), # <-- because EI is maximized!
                    gp=gp,dgt=dgt)
        info = "EI"
      } else {
        res = optim(par=x0,fn=PI,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt,fnscale=-1), # <-- because PI is maximized!
                    gp=gp)
        info = "PI"
      }
      if( i==1 || res$value>res.best$value ) # <-- because EI and PI are maximized!
        res.best = res
    }
  } else {
    
    xc = xc.prev = rep(0.5,gp@d)
    notImproved = 0
    len = 1
    while( notImproved<5 && len>=0.01 ) {
      x0s = round(maximinLHS(100*gp@d,gp@d) * len + xc-len/2, dgt)
      x0s = rbind(xc,x0s)
      x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
      
      if( nrow(gp@X)<=floor(N*rate) ) {
        # EI
        y0s = round(apply(x0s,1,EI,gp=gp,dgt=dgt),dgt)
        info = "EI"
      } else { 
        # PI
        y0s = round(apply(x0s,1,PI,gp=gp),dgt)
        info = "PI"
      }
      
      xc = x0s[which.max(y0s),] # <-- because EI and PI are maximized!
      len = 3 * len/4
      if( all(xc==xc.prev) ) {
        notImproved = notImproved+1
      } else {
        xc.prev = xc
        notImproved = 0
      }
    }
    res.best = list(par=xc)
  }
  
  next.PIisBack.switching = list(par=res.best$par,af.info=info,af.note=paste0("rate=",rate))
}



# Alternating between CB and uncertainty (i.e. Inverse Weighted Distance ) reduction
next.CB_UR.alternating <- function(gp,dgt,beta,lbfgsb=F) {
  if( lbfgsb ) {
    x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
    if( nrow(gp@X)%%2==0 ) {
      y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
      x0s = x0s[order(y0s,decreasing=F)[1:5],]
    } else {
      y0s = round(apply(x0s,1,idw,XX=as.matrix(gp@X),dgt=dgt),dgt)
      x0s = x0s[order(y0s,decreasing=T)[1:5],] # <-- because iwd is maximized!
    }
    for( i in 1:nrow(x0s) ) {
      x0 = x0s[i,]
      if( nrow(gp@X)%%2==0 ) {
        res = optim(par=x0,fn=gp.lcb,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt),
                    gp=gp,beta=beta)
        info = "CB"
        if( i==1 || res$value<res.best$value )
          res.best = res
      } else {
        res = optim(par=x0,fn=idw,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt,fnscale=-1), # <-- because iwd is maximized!
                    XX=as.matrix(gp@X),dgt=dgt)
        info = "UR"
        if( i==1 || res$value>res.best$value ) # <-- because iwd is maximized!
          res.best = res
      }
      
    }
  } else {
    
    xc = xc.prev = rep(0.5,gp@d)
    notImproved = 0
    len = 1
    while( notImproved<5 && len>=0.01 ) {
      x0s = round(maximinLHS(100*gp@d,gp@d) * len + xc-len/2, dgt)
      x0s = rbind(xc,x0s)
      x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
      
      if( nrow(gp@X)%%2==0 ) {
        # CB
        y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
        info = "CB"
        xc = x0s[which.min(y0s),]
      } else { 
        # UR
        y0s = round(apply(x0s,1,idw,XX=as.matrix(gp@X),dgt=dgt),dgt)
        info = "UR"
        xc = x0s[which.max(y0s),] # <-- because idw is maximized
      }
      
      len = 3 * len/4
      if( all(xc==xc.prev) ) {
        notImproved = notImproved+1
      } else {
        xc.prev = xc
        notImproved = 0
      }
    }
    res.best = list(par=xc)
  }
  
  next.CB_UR.alternating = list(par=res.best$par,af.info=info,af.note=paste0("beta=",beta))
}

# Switching from uncertainty (i.e. Inverse Weighted Distance ) reduction to CB
next.CB_UR.switching <- function(gp,N,rate,dgt,beta,lbfgsb=F) {
  if( lbfgsb ) {
    x0s = round(maximinLHS(100*gp@d,gp@d),dgt)
    if( nrow(gp@X)>floor(N*rate) ) {
      y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
      x0s = x0s[order(y0s,decreasing=F)[1:5],]
    } else {
      y0s = round(apply(x0s,1,idw,XX=as.matrix(gp@X),dgt=dgt),dgt)
      x0s = x0s[order(y0s,decreasing=T)[1:5],] # because idw is maximized!
    }
    
    for( i in 1:nrow(x0s) ) {
      x0 = x0s[i,]
      if( nrow(gp@X)>floor(N*rate) ) {
        res = optim(par=x0,fn=gp.lcb,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt),
                    gp=gp,beta=beta)
        info = "CB"
        if( i==1 || res$value<res.best$value )
          res.best = res
      } else {
        res = optim(par=x0,fn=idw,gr=NULL,method="L-BFGS-B",lower=0,upper=1,
                    control=list(trace=0,factr=10^-dgt,fnscale=-1), # <-- because idw is maximized!
                    XX=as.matrix(gp@X),dgt=dgt)
        info = "UR"
        if( i==1 || res$value>res.best$value ) # <-- because idw is maximized!
          res.best = res
      }
    }
  } else {
    
    xc = xc.prev = rep(0.5,gp@d)
    notImproved = 0
    len = 1
    while( notImproved<5 && len>=0.01 ) {
      x0s = round(maximinLHS(100*gp@d,gp@d) * len + xc-len/2, dgt)
      x0s = rbind(xc,x0s)
      x0s[which(x0s<0)] = 0; x0s[which(x0s>1)] = 1
      
      if( nrow(gp@X)>floor(N*rate) ) {
        # CB
        y0s = round(apply(x0s,1,gp.lcb,gp=gp,beta=beta),dgt)
        info = "CB"
        xc = x0s[which.min(y0s),]
      } else { 
        # UR
        y0s = round(apply(x0s,1,idw,XX=as.matrix(gp@X),dgt=dgt),dgt)
        info = "UR"
        xc = x0s[which.max(y0s),] # <-- because idw is maximized
      }
      
      len = 3 * len/4
      if( all(xc==xc.prev) ) {
        notImproved = notImproved+1
      } else {
        xc.prev = xc
        notImproved = 0
      }
    }
    res.best = list(par=xc)
  }
  
  next.CB_UR.switching = list(par=res.best$par,af.info=info,af.note=paste0("beta=",beta))
}

